{"version":3,"file":"unchanged.js","sources":["../src/utils.ts","../src/handlers.ts","../src/index.ts"],"sourcesContent":["// external dependencies\nimport { parse } from 'pathington';\n\nconst O = Object;\nconst {\n  create,\n  getOwnPropertySymbols,\n  getPrototypeOf,\n  keys,\n  propertyIsEnumerable,\n} = O;\nconst { toString: toStringObject } = O.prototype;\n\nconst { toString: toStringFunction } = Function.prototype;\n\nconst { isArray } = Array;\n\n/**\n * @constant FUNCTION_NAME the RegExp expression matching function names\n */\nconst FUNCTION_NAME = /^\\s*function\\s*([^\\(]*)/i;\n\n/**\n * @constant REACT_ELEMENT the symbol / number specific to react elements\n */\nconst REACT_ELEMENT: symbol | number =\n  typeof Symbol === 'function' && typeof Symbol.for === 'function'\n    ? Symbol.for('react.element')\n    : 0xeac7;\n\n/**\n * @function cloneArray\n *\n * @description\n * clone an array to a new array\n *\n * @param array the array to clone\n * @returns the cloned array\n */\nexport const cloneArray: Function = (array: any[]): any[] => {\n  // @ts-ignore\n  const cloned = new array.constructor();\n\n  for (let index = 0; index < array.length; index++) {\n    cloned[index] = array[index];\n  }\n\n  return cloned;\n};\n\n/**\n * @function reduce\n *\n * @description\n * a targeted reduce method faster than the native\n *\n * @param array the array to reduce\n * @param fn the method to reduce each array value with\n * @param initialValue the initial value of the reduction\n * @returns the reduced value\n */\nexport const reduce = (array: any[], fn: Function, initialValue: any): any => {\n  let value: any = initialValue;\n\n  for (let index: number = 0; index < array.length; index++) {\n    value = fn(value, array[index]);\n  }\n\n  return value;\n};\n\n/**\n * @function getOwnProperties\n *\n * @description\n * get the all properties (keys and symbols) of the object passed\n *\n * @param object the object to get the properties of\n * @returns the keys and symbols the object has\n */\nexport const getOwnProperties: Function = (\n  object: unchanged.Unchangeable,\n): (string | symbol)[] => {\n  const ownSymbols: symbol[] = getOwnPropertySymbols(object);\n\n  if (!ownSymbols.length) {\n    return keys(object);\n  }\n\n  return keys(object).concat(\n    reduce(\n      ownSymbols,\n      (enumerableSymbols: symbol[], symbol: symbol): symbol[] => {\n        if (propertyIsEnumerable.call(object, symbol)) {\n          enumerableSymbols.push(symbol);\n        }\n\n        return enumerableSymbols;\n      },\n      [],\n    ),\n  );\n};\n\n/**\n * @function assignFallback\n *\n * @description\n * a targeted fallback if native Object.assign is unavailable\n *\n * @param target the object to shallowly merge into\n * @param source the object to shallowly merge into target\n * @returns the shallowly merged object\n */\nexport const assignFallback: Function = (\n  target: unchanged.Unchangeable,\n  source: unchanged.Unchangeable,\n): unchanged.Unchangeable => {\n  if (!source) {\n    return target;\n  }\n\n  return reduce(\n    getOwnProperties(source),\n    (\n      clonedObject: unchanged.Unchangeable,\n      property: string,\n    ): unchanged.Unchangeable => {\n      clonedObject[property] = source[property];\n\n      return clonedObject;\n    },\n    Object(target),\n  );\n};\n\nconst assign: Function =\n  typeof O.assign === 'function' ? O.assign : assignFallback;\n\n/**\n * @function createWithProto\n *\n * @description\n * create a new object with the prototype of the object passed\n *\n * @param object object whose prototype will be the new object's prototype\n * @returns object with the prototype of the one passed\n */\nexport const createWithProto: Function = (\n  object: unchanged.Unchangeable,\n): unchanged.Unchangeable => create(object.__proto__ || getPrototypeOf(object));\n\n/**\n * @function isCloneable\n *\n * @description\n * is the object passed considered cloneable\n *\n * @param object the object that is being checked for cloneability\n * @returns whether the object can be cloned\n */\nexport const isCloneable: Function = (object: any): boolean => {\n  if (\n    !object ||\n    typeof object !== 'object' ||\n    object.$$typeof === REACT_ELEMENT\n  ) {\n    return false;\n  }\n\n  const type: string = toStringObject.call(object);\n\n  return type !== '[object Date]' && type !== '[object RegExp]';\n};\n\n/**\n * @function isEmptyPath\n *\n * @description\n * is the path passed an empty path\n *\n * @param path the path to check for emptiness\n * @returns whether the path passed is considered empty\n */\nexport const isEmptyPath: Function = (path: any): boolean =>\n  path == null || (isArray(path) && !path.length);\n\n/**\n * @function isGlobalConstructor\n *\n * @description\n * is the fn passed a global constructor\n *\n * @param fn the fn to check if a global constructor\n * @returns whether the fn passed is a global constructor\n */\nexport const isGlobalConstructor: Function = (fn: any): boolean =>\n  typeof fn === 'function' &&\n  !!~toStringFunction.call(fn).indexOf('[native code]');\n\n/**\n * @function callIfFunction\n *\n * @description\n * if the object passed is a function, call it and return its return, else return undefined\n *\n * @param object the object to call if a function\n * @param context the context to call the function with\n * @param parameters the parameters to call the function with\n * @returns the result of the function call, or undefined\n */\nexport const callIfFunction = (\n  object: any,\n  context: any,\n  parameters: any[],\n): any =>\n  typeof object === 'function' ? object.apply(context, parameters) : void 0;\n\n/**\n * @function getNewEmptyChild\n *\n * @description\n * get a new empty child object based on the key passed\n *\n * @param key the key to base the empty child on\n * @returns the empty object the child is built from\n */\nexport const getNewEmptyChild: Function = (key: any): unchanged.Unchangeable =>\n  typeof key === 'number' ? [] : {};\n\n/**\n * @function getNewEmptyObject\n *\n * @description\n * get a new empty object based on the object passed\n *\n * @param object the object to base the empty object on\n * @returns an empty version of the object passed\n */\nexport const getNewEmptyObject: Function = (\n  object: unchanged.Unchangeable,\n): unchanged.Unchangeable => (isArray(object) ? [] : {});\n\n/**\n * @function getShallowClone\n *\n * @description\n * create a shallow clone of the object passed, respecting its prototype\n *\n * @param object the object to clone\n * @returns a shallow clone of the object passed\n */\nexport const getShallowClone = (\n  object: unchanged.Unchangeable,\n): unchanged.Unchangeable => {\n  if (object.constructor === O) {\n    return assign({}, object);\n  }\n\n  if (isArray(object)) {\n    return cloneArray(object);\n  }\n\n  return isGlobalConstructor(object.constructor)\n    ? {}\n    : assign(createWithProto(object), object);\n};\n\n/**\n * @function isSameValueZero\n *\n * @description\n * are the values equal based on SameValueZero\n *\n * @param value1 the first value to test\n * @param value2 the second value to test\n * @returns are the two values passed equal based on SameValueZero\n */\nexport const isSameValueZero: Function = (value1: any, value2: any): boolean =>\n  value1 === value2 || (value1 !== value1 && value2 !== value2);\n\n/**\n * @function cloneIfPossible\n *\n * @description\n * clone the object if it can be cloned, otherwise return the object itself\n *\n * @param object the object to clone\n * @returns a cloned version of the object, or the object itself if not cloneable\n */\nexport const cloneIfPossible: Function = (object: any): any =>\n  isCloneable(object) ? getShallowClone(object) : object;\n\n/**\n * @function getCloneOrEmptyObject\n *\n * @description\n * if the object is cloneable, get a clone of the object, else get a new\n * empty child object based on the key\n *\n * @param object the object to clone\n * @param nextKey the key to base the empty child object on\n * @returns a clone of the object, or an empty child object\n */\nexport const getCloneOrEmptyObject: Function = (\n  object: unchanged.Unchangeable,\n  nextKey: any,\n): unchanged.Unchangeable =>\n  isCloneable(object) ? getShallowClone(object) : getNewEmptyChild(nextKey);\n\n/**\n * @function getCoalescedValue\n *\n * @description\n * return the value if not undefined, otherwise return the fallback value\n *\n * @param value the value to coalesce if undefined\n * @param fallbackValue the value to coalesce to\n * @returns the coalesced value\n */\nexport const getCoalescedValue: Function = (\n  value: any,\n  fallbackValue: any,\n): any => (value === void 0 ? fallbackValue : value);\n\n/**\n * @function getParsedPath\n *\n * @description\n * parse the path passed into an array path\n *\n * @param path the path to parse\n * @returns the parsed path\n */\nexport const getParsedPath: Function = (\n  path: unchanged.Path,\n): unchanged.ParsedPath => (isArray(path) ? path : parse(path));\n\n/**\n * @function getCloneAtPath\n *\n * @description\n * get a new object, cloned at the path specified while leveraging\n * structural sharing for the rest of the properties\n *\n * @param path the path to clone at\n * @param object the object with cloned children at path\n * @param onMatch the method to call once the end of the path is reached\n * @param index the path index\n * @returns the object deeply cloned at the path specified\n */\nexport const getCloneAtPath: Function = (\n  path: unchanged.ParsedPath,\n  object: unchanged.Unchangeable,\n  onMatch: Function,\n  index: number,\n): any => {\n  const key: unchanged.PathItem = path[index];\n  const nextIndex: number = index + 1;\n\n  if (nextIndex === path.length) {\n    onMatch(object, key);\n  } else {\n    object[key] = getCloneAtPath(\n      path,\n      getCloneOrEmptyObject(object[key], path[nextIndex]),\n      onMatch,\n      nextIndex,\n    );\n  }\n\n  return object;\n};\n\n/**\n * @function getDeepClone\n *\n * @description\n * get a clone of the object at the path specified\n *\n * @param path the path to clone at\n * @param object the object to clone at the path\n * @param onMatch once a patch match is found, the callback to fire\n * @returns the clone of the object at path specified\n */\nexport const getDeepClone: Function = (\n  path: unchanged.Path,\n  object: unchanged.Unchangeable,\n  onMatch: Function,\n): unchanged.Unchangeable => {\n  const parsedPath: unchanged.ParsedPath = getParsedPath(path);\n  const topLevelClone: unchanged.Unchangeable = getCloneOrEmptyObject(\n    object,\n    parsedPath[0],\n  );\n\n  if (parsedPath.length === 1) {\n    onMatch(topLevelClone, parsedPath[0]);\n\n    return topLevelClone;\n  }\n\n  return getCloneAtPath(parsedPath, topLevelClone, onMatch, 0);\n};\n\n/**\n * @function getMergedObject\n *\n * @description\n * merge the source into the target, either deeply or shallowly\n *\n * @param target the object to merge into\n * @param source the object being merged into the target\n * @param isDeep is the merge a deep merge\n * @returns the merged object\n */\nexport const getMergedObject: Function = (\n  target: unchanged.Unchangeable,\n  source: unchanged.Unchangeable,\n  isDeep: boolean,\n): unchanged.Unchangeable => {\n  const isObject1Array: boolean = isArray(target);\n\n  if (isObject1Array !== isArray(source) || !isCloneable(target)) {\n    return cloneIfPossible(source);\n  }\n\n  if (isObject1Array) {\n    return target.concat(source);\n  }\n\n  const targetClone: unchanged.Unchangeable =\n    target.constructor === O || isGlobalConstructor(target.constructor)\n      ? {}\n      : createWithProto(target);\n\n  return reduce(\n    getOwnProperties(source),\n    (clone: unchanged.Unchangeable, key: string): unchanged.Unchangeable => {\n      clone[key] =\n        isDeep && isCloneable(source[key])\n          ? getMergedObject(target[key], source[key], isDeep)\n          : source[key];\n\n      return clone;\n    },\n    assign(targetClone, target),\n  );\n};\n\n/**\n * @function getValueAtPath\n *\n * @description\n * get the value at the nested property, or the fallback provided\n *\n * @param path the path to get the value from\n * @param object the object to get the value from at path\n * @param noMatchValue the value returned if no match is found\n * @returns the matching value, or the fallback provided\n */\nexport const getValueAtPath: Function = (\n  path: unchanged.Path,\n  object: unchanged.Unchangeable,\n  noMatchValue?: any,\n) => {\n  const parsedPath = getParsedPath(path);\n\n  if (parsedPath.length === 1) {\n    return object\n      ? getCoalescedValue(object[parsedPath[0]], noMatchValue)\n      : noMatchValue;\n  }\n\n  let ref: any = object;\n  let key: number | string = parsedPath[0];\n\n  for (let index: number = 0; index < parsedPath.length - 1; index++) {\n    if (!ref || !ref[key]) {\n      return noMatchValue;\n    }\n\n    ref = ref[key];\n    key = parsedPath[index + 1];\n  }\n\n  return ref ? getCoalescedValue(ref[key], noMatchValue) : noMatchValue;\n};\n\n/**\n * @function getFullPath\n *\n * @description\n * get the path to add to, based on the object and fn passed\n *\n * @param path the path to add to\n * @param object the object traversed by the path\n * @param fn the function to transform the retrieved value with\n * @returns the full path to add to\n */\nexport const getFullPath: Function = (\n  path: unchanged.Path,\n  object: unchanged.Unchangeable,\n  fn?: Function,\n): unchanged.Path => {\n  const isPathEmpty: boolean = isEmptyPath(path);\n  const valueAtPath: any = isPathEmpty\n    ? object\n    : fn\n    ? fn(getValueAtPath(path, object))\n    : getValueAtPath(path, object);\n\n  return isArray(valueAtPath)\n    ? isArray(path)\n      ? path.concat([valueAtPath.length])\n      : `${isPathEmpty ? '' : path}[${valueAtPath.length}]`\n    : path;\n};\n\n/**\n * @function splice\n *\n * @description\n * a faster, more targeted version of the native splice\n *\n * @param array the array to remove the value from\n * @param splicedIndex the index of the value to remove\n */\nexport const splice: Function = (array: any[], splicedIndex: number): void => {\n  if (array.length) {\n    const { length } = array;\n\n    let index: number = splicedIndex;\n\n    while (index < length - 1) {\n      array[index] = array[index + 1];\n\n      ++index;\n    }\n\n    --array.length;\n  }\n};\n\n/**\n * @function throwInvalidFnError\n *\n * @description\n * throw the TypeError based on the invalid handler\n *\n * @throws\n */\nexport const throwInvalidFnError: Function = (): never => {\n  throw new TypeError('handler passed is not of type \"function\".');\n};\n","// utils\nimport {\n  callIfFunction,\n  getDeepClone,\n  getFullPath,\n  getMergedObject,\n  getValueAtPath,\n  getNewEmptyObject,\n  isCloneable,\n  isEmptyPath,\n  isSameValueZero,\n  splice,\n  throwInvalidFnError,\n} from './utils';\n\nconst { isArray } = Array;\nconst { slice } = Array.prototype;\n\n/**\n * @function createCall\n *\n * @description\n * create handlers for call / callWith\n *\n * @param isWithHandler is the method using a with handler\n * @returns call / callWith\n */\nexport const createCall: Function = (isWithHandler: boolean): Function => {\n  if (isWithHandler) {\n    return function (\n      fn: unchanged.withHandler,\n      path: unchanged.Path,\n      parameters: any[],\n      object: unchanged.Unchangeable | Function,\n      context: any = object,\n    ): any {\n      if (typeof fn !== 'function') {\n        throwInvalidFnError();\n      }\n\n      const extraArgs: any[] = slice.call(arguments, 5);\n\n      if (isEmptyPath(path)) {\n        return callIfFunction(fn(object, ...extraArgs), context, parameters);\n      }\n\n      const value: any = getValueAtPath(path, object);\n\n      if (value === void 0) {\n        return;\n      }\n\n      const result: any = fn(value, ...extraArgs);\n\n      return callIfFunction(result, context, parameters);\n    };\n  }\n\n  return (\n    path: unchanged.Path,\n    parameters: any[],\n    object: unchanged.Unchangeable | Function,\n    context = object,\n  ): any => {\n    const callable: any = isEmptyPath(path)\n      ? object\n      : getValueAtPath(path, object);\n\n    return callIfFunction(callable, context, parameters);\n  };\n};\n\n/**\n * @function createGet\n *\n * @description\n * create handlers for get / getWith\n *\n * @param isWithHandler is the method using a with handler\n * @returns get / getWith\n */\nexport const createGet: Function = (isWithHandler: boolean): Function => {\n  if (isWithHandler) {\n    return function (\n      fn: unchanged.withHandler,\n      path: unchanged.Path,\n      object: unchanged.Unchangeable,\n    ): any {\n      if (typeof fn !== 'function') {\n        throwInvalidFnError();\n      }\n\n      const extraArgs: any[] = slice.call(arguments, 4);\n\n      if (isEmptyPath(path)) {\n        return fn(object, ...extraArgs);\n      }\n\n      const value: any = getValueAtPath(path, object);\n\n      return value === void 0 ? value : fn(value, ...extraArgs);\n    };\n  }\n\n  return (path: unchanged.Path, object: unchanged.Unchangeable): any =>\n    isEmptyPath(path) ? object : getValueAtPath(path, object);\n};\n\n/**\n * @function createGetOr\n *\n * @description\n * create handlers for getOr / getWithOr\n *\n * @param isWithHandler is the method using a with handler\n * @returns getOr / getWithOr\n */\nexport const createGetOr: Function = (isWithHandler: boolean): Function => {\n  if (isWithHandler) {\n    return function (\n      fn: unchanged.withHandler,\n      noMatchValue: any,\n      path: unchanged.Path,\n      object: unchanged.Unchangeable,\n    ): any {\n      if (typeof fn !== 'function') {\n        throwInvalidFnError();\n      }\n\n      const extraArgs: any[] = slice.call(arguments, 4);\n\n      if (isEmptyPath(path)) {\n        return fn(object, ...extraArgs);\n      }\n\n      const value: any = getValueAtPath(path, object);\n\n      return value === void 0 ? noMatchValue : fn(value, ...extraArgs);\n    };\n  }\n\n  return (\n    noMatchValue: any,\n    path: unchanged.Path,\n    object: unchanged.Unchangeable,\n  ): any =>\n    isEmptyPath(path) ? object : getValueAtPath(path, object, noMatchValue);\n};\n\n/**\n * @function createHas\n *\n * @description\n * create handlers for has / hasWith\n *\n * @param isWithHandler is the method using a with handler\n * @returns has / hasWith\n */\nexport const createHas: Function = (isWithHandler: boolean): Function => {\n  if (isWithHandler) {\n    return function (\n      fn: unchanged.withHandler,\n      path: unchanged.Path,\n      object: unchanged.Unchangeable,\n    ): boolean {\n      if (typeof fn !== 'function') {\n        throwInvalidFnError();\n      }\n\n      const extraArgs: any[] = slice.call(arguments, 3);\n\n      if (isEmptyPath(path)) {\n        return !!fn(object, ...extraArgs);\n      }\n\n      const value: any = getValueAtPath(path, object);\n\n      return value !== void 0 && !!fn(value, ...extraArgs);\n    };\n  }\n\n  return (path: unchanged.Path, object: unchanged.Unchangeable): boolean =>\n    isEmptyPath(path)\n      ? object != null\n      : getValueAtPath(path, object) !== void 0;\n};\n\n/**\n * @function createIs\n *\n * @description\n * create handlers for is / isWith\n *\n * @param isWithHandler is the method using a with handler\n * @returns is / isWith\n */\nexport const createIs: Function = (isWithHandler: boolean): Function => {\n  if (isWithHandler) {\n    return function (\n      fn: unchanged.withHandler,\n      path: unchanged.Path,\n      value: any,\n      object: unchanged.Unchangeable,\n    ): boolean {\n      if (typeof fn !== 'function') {\n        throwInvalidFnError();\n      }\n\n      const extraArgs: any[] = slice.call(arguments, 4);\n\n      if (isEmptyPath(path)) {\n        return isSameValueZero(fn(object, ...extraArgs), value);\n      }\n\n      return isSameValueZero(\n        fn(getValueAtPath(path, object), ...extraArgs),\n        value,\n      );\n    };\n  }\n\n  return (\n    path: unchanged.Path,\n    value: any,\n    object: unchanged.Unchangeable,\n  ): boolean =>\n    isEmptyPath(path)\n      ? isSameValueZero(object, value)\n      : isSameValueZero(getValueAtPath(path, object), value);\n};\n\n/**\n * @function createMerge\n *\n * @description\n * create handlers for merge / mergeWith\n *\n * @param isWithHandler is the method using a with handler\n * @param isDeep is the handler for a deep merge or shallow\n * @returns merge / mergeWith\n */\nexport const createMerge: Function = (\n  isWithHandler: boolean,\n  isDeep: boolean,\n): Function => {\n  if (isWithHandler) {\n    return function (\n      fn: unchanged.withHandler,\n      path: unchanged.Path,\n      object: unchanged.Unchangeable,\n    ): unchanged.Unchangeable {\n      if (typeof fn !== 'function') {\n        throwInvalidFnError();\n      }\n\n      const extraArgs: any[] = slice.call(arguments, 3);\n\n      if (!isCloneable(object)) {\n        return fn(object, ...extraArgs);\n      }\n\n      if (isEmptyPath(path)) {\n        const objectToMerge: any = fn(object, ...extraArgs);\n\n        return objectToMerge\n          ? getMergedObject(object, objectToMerge, isDeep)\n          : object;\n      }\n\n      let hasChanged: boolean = false;\n\n      const result: unchanged.Unchangeable = getDeepClone(\n        path,\n        object,\n        (ref: unchanged.Unchangeable, key: string): void => {\n          const objectToMerge: any = fn(ref[key], ...extraArgs);\n\n          if (objectToMerge) {\n            ref[key] = getMergedObject(ref[key], objectToMerge, isDeep);\n\n            hasChanged = true;\n          }\n        },\n      );\n\n      return hasChanged ? result : object;\n    };\n  }\n\n  return (\n    path: unchanged.Path,\n    objectToMerge: unchanged.Unchangeable,\n    object: unchanged.Unchangeable,\n  ): unchanged.Unchangeable => {\n    if (!isCloneable(object)) {\n      return objectToMerge;\n    }\n\n    return isEmptyPath(path)\n      ? getMergedObject(object, objectToMerge, true)\n      : getDeepClone(\n          path,\n          object,\n          (ref: unchanged.Unchangeable, key: string): void => {\n            ref[key] = getMergedObject(ref[key], objectToMerge, isDeep);\n          },\n        );\n  };\n};\n\n/**\n * @function createNot\n *\n * @description\n * create handlers for not / notWith\n *\n * @param isWithHandler not the method using a with handler\n * @returns not / notWithHandler\n */\nexport const createNot: Function = (isWithHandler: boolean): Function => {\n  const is: Function = createIs(isWithHandler);\n\n  return function () {\n    return !is.apply(this, arguments);\n  };\n};\n\n/**\n * @function createRemove\n *\n * @description\n * create handlers for remove / removeWith\n *\n * @param isWithHandler is the method using a with handler\n * @returns remove / removeWith\n */\nexport const createRemove: Function = (isWithHandler: boolean): Function => {\n  if (isWithHandler) {\n    return function (\n      fn: unchanged.withHandler,\n      path: unchanged.Path,\n      object: unchanged.Unchangeable,\n    ): unchanged.Unchangeable {\n      if (typeof fn !== 'function') {\n        throwInvalidFnError();\n      }\n\n      const extraArgs: any[] = slice.call(arguments, 3);\n\n      if (isEmptyPath(path)) {\n        const emptyObject: unchanged.Unchangeable = getNewEmptyObject(object);\n\n        return fn(emptyObject, ...extraArgs) ? emptyObject : object;\n      }\n\n      const value: any = getValueAtPath(path, object);\n\n      return value !== void 0 && fn(value, ...extraArgs)\n        ? getDeepClone(\n            path,\n            object,\n            (ref: unchanged.Unchangeable, key: string): void => {\n              if (isArray(ref)) {\n                splice(ref, key);\n              } else {\n                delete ref[key];\n              }\n            },\n          )\n        : object;\n    };\n  }\n\n  return (\n    path: unchanged.Path,\n    object: unchanged.Unchangeable,\n  ): unchanged.Unchangeable => {\n    if (isEmptyPath(path)) {\n      return getNewEmptyObject(object);\n    }\n\n    return getValueAtPath(path, object) !== void 0\n      ? getDeepClone(\n          path,\n          object,\n          (ref: unchanged.Unchangeable, key: string): void => {\n            if (isArray(ref)) {\n              splice(ref, key);\n            } else {\n              delete ref[key];\n            }\n          },\n        )\n      : object;\n  };\n};\n\n/**\n * @function createSet\n *\n * @description\n * create handlers for set / setWith\n *\n * @param isWithHandler is the method using a with handler\n * @returns set / setWith\n */\nexport const createSet: Function = (isWithHandler: boolean): Function => {\n  if (isWithHandler) {\n    return function (\n      fn: unchanged.withHandler,\n      path: unchanged.Path,\n      object: unchanged.Unchangeable,\n    ): unchanged.Unchangeable {\n      if (typeof fn !== 'function') {\n        throwInvalidFnError();\n      }\n\n      const extraArgs: any[] = slice.call(arguments, 3);\n\n      return isEmptyPath(path)\n        ? fn(object, ...extraArgs)\n        : getDeepClone(\n            path,\n            object,\n            (ref: unchanged.Unchangeable, key: string): void => {\n              ref[key] = fn(ref[key], ...extraArgs);\n            },\n          );\n    };\n  }\n\n  return (\n    path: unchanged.Path,\n    value: any,\n    object: unchanged.Unchangeable,\n  ): unchanged.Unchangeable =>\n    isEmptyPath(path)\n      ? value\n      : getDeepClone(\n          path,\n          object,\n          (ref: unchanged.Unchangeable, key: string): void => {\n            ref[key] = value;\n          },\n        );\n};\n\n/**\n * @function createAdd\n *\n * @description\n * create handlers for add / addWith\n *\n * @param isWithHandler is the method using a with handler\n * @returns add / addWith\n */\nexport const createAdd: Function = (isWithHandler: boolean): Function => {\n  const add: Function = createSet(isWithHandler);\n\n  if (isWithHandler) {\n    return function (\n      fn: unchanged.withHandler,\n      path: unchanged.Path,\n      object: unchanged.Unchangeable,\n    ): unchanged.Unchangeable {\n      return add.apply(\n        this,\n        [fn, getFullPath(path, object, fn), object].concat(\n          slice.call(arguments, 3),\n        ),\n      );\n    };\n  }\n\n  return (\n    path: unchanged.Path,\n    value: any,\n    object: unchanged.Unchangeable,\n  ): unchanged.Unchangeable => add(getFullPath(path, object), value, object);\n};\n","// external dependencies\nimport { __, curry } from 'curriable';\n\n// handlers\nimport {\n  createAdd,\n  createCall,\n  createGet,\n  createGetOr,\n  createHas,\n  createIs,\n  createMerge,\n  createNot,\n  createRemove,\n  createSet,\n} from './handlers';\n\nexport { __ };\n\nexport const add = curry(createAdd(false), 3);\n\nexport const addWith = curry(createAdd(true), 3);\n\nexport const assign = curry(createMerge(false, false), 3);\n\nexport const assignWith = curry(createMerge(true, false), 3);\n\nexport const call = curry(createCall(false), 3);\n\nexport const callWith = curry(createCall(true), 4);\n\nexport const get = curry(createGet(false), 2);\n\nexport const getOr = curry(createGetOr(false), 3);\n\nexport const getWith = curry(createGet(true), 3);\n\nexport const getWithOr = curry(createGetOr(true), 4);\n\nexport const has = curry(createHas(false), 2);\n\nexport const hasWith = curry(createHas(true), 3);\n\nexport const is = curry(createIs(false), 3);\n\nexport const isWith = curry(createIs(true), 4);\n\nexport const merge = curry(createMerge(false, true), 3);\n\nexport const mergeWith = curry(createMerge(true, true), 3);\n\nexport const not = curry(createNot(false), 3);\n\nexport const notWith = curry(createNot(true), 4);\n\nexport const remove = curry(createRemove(false), 2);\n\nexport const removeWith = curry(createRemove(true), 3);\n\nexport const set = curry(createSet(false), 3);\n\nexport const setWith = curry(createSet(true), 3);\n"],"names":["parse","isArray","curry","assign"],"mappings":"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"}